import { google } from 'googleapis';
import { createReadStream } from 'fs';
import { logger } from '../utils/logger.js';
import { databaseService } from './databaseService.js';

class YouTubeService {
  constructor() {
    this.youtube = null;
    this.oauth2Client = null;
    this.initialize();
  }

  initialize() {
    if (!process.env.YOUTUBE_CLIENT_ID || !process.env.YOUTUBE_CLIENT_SECRET) {
      logger.warning('YouTube API credentials not configured');
      return;
    }

    try {
      this.oauth2Client = new google.auth.OAuth2(
        process.env.YOUTUBE_CLIENT_ID,
        process.env.YOUTUBE_CLIENT_SECRET,
        'http://localhost:3001/auth/youtube/callback' // Redirect URI
      );

      // Set refresh token if available
      if (process.env.YOUTUBE_REFRESH_TOKEN) {
        this.oauth2Client.setCredentials({
          refresh_token: process.env.YOUTUBE_REFRESH_TOKEN
        });
      }

      this.youtube = google.youtube({
        version: 'v3',
        auth: this.oauth2Client
      });

      logger.info('YouTube service initialized');
    } catch (error) {
      logger.error('Failed to initialize YouTube service', error);
    }
  }

  async uploadVideo(videoPath, metadata) {
    if (!this.youtube) {
      throw new Error('YouTube service not initialized');
    }

    const startTime = Date.now();

    try {
      logger.info('Starting YouTube video upload', {
        title: metadata.title,
        videoPath
      });

      // Prepare video metadata
      const videoMetadata = {
        snippet: {
          title: metadata.title,
          description: metadata.description || 'Automated news video generated by AutoNews',
          tags: metadata.tags || ['news', 'ai', 'automated'],
          categoryId: '25', // News & Politics category
          defaultLanguage: 'en',
          defaultAudioLanguage: 'en'
        },
        status: {
          privacyStatus: metadata.privacyStatus || 'public',
          embeddable: true,
          license: 'youtube'
        }
      };

      // Upload video
      const response = await this.youtube.videos.insert({
        part: ['snippet', 'status'],
        requestBody: videoMetadata,
        media: {
          body: createReadStream(videoPath)
        }
      });

      const responseTime = Date.now() - startTime;

      // Record API usage
      await databaseService.recordApiUsage(
        'youtube',
        '/videos',
        'POST',
        200,
        responseTime
      );

      const videoId = response.data.id;
      const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;

      logger.info('Video uploaded to YouTube successfully', {
        videoId,
        videoUrl,
        title: metadata.title,
        responseTime
      });

      return {
        videoId,
        videoUrl,
        title: response.data.snippet.title,
        description: response.data.snippet.description,
        publishedAt: response.data.snippet.publishedAt,
        privacyStatus: response.data.status.privacyStatus
      };

    } catch (error) {
      const responseTime = Date.now() - startTime;

      // Record API error
      await databaseService.recordApiUsage(
        'youtube',
        '/videos',
        'POST',
        error.response?.status || 0,
        responseTime,
        error.message
      );

      logger.error('Failed to upload video to YouTube', {
        error: error.message,
        status: error.response?.status,
        statusText: error.response?.statusText
      });

      throw error;
    }
  }

  async uploadThumbnail(videoId, thumbnailPath) {
    if (!this.youtube) {
      throw new Error('YouTube service not initialized');
    }

    const startTime = Date.now();

    try {
      logger.info('Uploading thumbnail to YouTube', { videoId, thumbnailPath });

      const response = await this.youtube.thumbnails.set({
        videoId: videoId,
        media: {
          body: createReadStream(thumbnailPath)
        }
      });

      const responseTime = Date.now() - startTime;

      // Record API usage
      await databaseService.recordApiUsage(
        'youtube',
        '/thumbnails',
        'POST',
        200,
        responseTime
      );

      logger.info('Thumbnail uploaded successfully', {
        videoId,
        responseTime
      });

      return response.data;

    } catch (error) {
      const responseTime = Date.now() - startTime;

      // Record API error
      await databaseService.recordApiUsage(
        'youtube',
        '/thumbnails',
        'POST',
        error.response?.status || 0,
        responseTime,
        error.message
      );

      logger.error('Failed to upload thumbnail', {
        videoId,
        error: error.message
      });

      throw error;
    }
  }

  async getVideoStats(videoId) {
    if (!this.youtube) {
      throw new Error('YouTube service not initialized');
    }

    try {
      const response = await this.youtube.videos.list({
        part: ['statistics', 'status'],
        id: [videoId]
      });

      if (response.data.items.length === 0) {
        throw new Error('Video not found');
      }

      const video = response.data.items[0];
      return {
        viewCount: parseInt(video.statistics.viewCount || 0),
        likeCount: parseInt(video.statistics.likeCount || 0),
        commentCount: parseInt(video.statistics.commentCount || 0),
        privacyStatus: video.status.privacyStatus
      };

    } catch (error) {
      logger.error('Failed to get video stats', {
        videoId,
        error: error.message
      });
      throw error;
    }
  }

  async updateVideoMetadata(videoId, updates) {
    if (!this.youtube) {
      throw new Error('YouTube service not initialized');
    }

    try {
      logger.info('Updating video metadata', { videoId, updates });

      const response = await this.youtube.videos.update({
        part: ['snippet', 'status'],
        requestBody: {
          id: videoId,
          snippet: updates.snippet,
          status: updates.status
        }
      });

      logger.info('Video metadata updated successfully', { videoId });
      return response.data;

    } catch (error) {
      logger.error('Failed to update video metadata', {
        videoId,
        error: error.message
      });
      throw error;
    }
  }

  async deleteVideo(videoId) {
    if (!this.youtube) {
      throw new Error('YouTube service not initialized');
    }

    try {
      logger.info('Deleting video from YouTube', { videoId });

      await this.youtube.videos.delete({
        id: videoId
      });

      logger.info('Video deleted successfully', { videoId });
      return true;

    } catch (error) {
      logger.error('Failed to delete video', {
        videoId,
        error: error.message
      });
      throw error;
    }
  }

  async getChannelInfo() {
    if (!this.youtube) {
      throw new Error('YouTube service not initialized');
    }

    try {
      const response = await this.youtube.channels.list({
        part: ['snippet', 'statistics'],
        mine: true
      });

      if (response.data.items.length === 0) {
        throw new Error('No channel found');
      }

      const channel = response.data.items[0];
      return {
        id: channel.id,
        title: channel.snippet.title,
        description: channel.snippet.description,
        subscriberCount: parseInt(channel.statistics.subscriberCount || 0),
        videoCount: parseInt(channel.statistics.videoCount || 0),
        viewCount: parseInt(channel.statistics.viewCount || 0)
      };

    } catch (error) {
      logger.error('Failed to get channel info', { error: error.message });
      throw error;
    }
  }

  generateAuthUrl(scopes = ['https://www.googleapis.com/auth/youtube.upload']) {
    if (!this.oauth2Client) {
      throw new Error('OAuth2 client not initialized');
    }

    return this.oauth2Client.generateAuthUrl({
      access_type: 'offline',
      scope: scopes,
      prompt: 'consent'
    });
  }

  async getTokenFromCode(code) {
    if (!this.oauth2Client) {
      throw new Error('OAuth2 client not initialized');
    }

    try {
      const { tokens } = await this.oauth2Client.getToken(code);
      this.oauth2Client.setCredentials(tokens);
      
      logger.info('YouTube OAuth tokens obtained successfully');
      return tokens;

    } catch (error) {
      logger.error('Failed to get YouTube OAuth tokens', { error: error.message });
      throw error;
    }
  }

  async refreshAccessToken() {
    if (!this.oauth2Client) {
      throw new Error('OAuth2 client not initialized');
    }

    try {
      const { credentials } = await this.oauth2Client.refreshAccessToken();
      this.oauth2Client.setCredentials(credentials);
      
      logger.info('YouTube access token refreshed successfully');
      return credentials;

    } catch (error) {
      logger.error('Failed to refresh YouTube access token', { error: error.message });
      throw error;
    }
  }

  isConfigured() {
    return this.youtube !== null && this.oauth2Client !== null;
  }

  async publishJobVideo(job, videoPath, thumbnailPath = null) {
    try {
      if (!this.isConfigured()) {
        throw new Error('YouTube service not configured');
      }

      // Prepare video metadata
      const metadata = {
        title: job.title,
        description: this.generateVideoDescription(job),
        tags: ['news', 'ai', 'automated', ...job.keywords],
        privacyStatus: 'public'
      };

      // Upload video
      const uploadResult = await this.uploadVideo(videoPath, metadata);

      // Upload thumbnail if provided
      if (thumbnailPath) {
        try {
          await this.uploadThumbnail(uploadResult.videoId, thumbnailPath);
        } catch (error) {
          logger.warning('Failed to upload thumbnail, continuing', { error: error.message });
        }
      }

      // Update job with YouTube information
      await databaseService.updateJob(job.id, {
        youtube_url: uploadResult.videoUrl,
        youtube_video_id: uploadResult.videoId,
        status: 'completed'
      });

      logger.info('Job video published to YouTube successfully', {
        jobId: job.id,
        videoId: uploadResult.videoId,
        videoUrl: uploadResult.videoUrl
      });

      return uploadResult;

    } catch (error) {
      logger.error('Failed to publish job video to YouTube', {
        jobId: job.id,
        error: error.message
      });

      // Update job status to failed
      await databaseService.updateJob(job.id, {
        status: 'failed',
        error_message: `YouTube upload failed: ${error.message}`
      });

      throw error;
    }
  }

  generateVideoDescription(job) {
    const articles = job.articles || [];
    let description = `${job.title}\n\n`;
    
    if (job.summary) {
      description += `${job.summary}\n\n`;
    }

    if (articles.length > 0) {
      description += 'Sources:\n';
      articles.forEach((article, index) => {
        description += `${index + 1}. ${article.title} - ${article.source_name}\n`;
      });
      description += '\n';
    }

    description += 'This video was automatically generated by AutoNews - AI-powered news content creation.\n\n';
    description += '#News #AI #Automated #Technology';

    return description;
  }
}

export const youtubeService = new YouTubeService();